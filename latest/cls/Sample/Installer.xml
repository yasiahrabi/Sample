<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2017.2 (Build 691U)" ts="2017-07-05 11:47:55">
<Class name="Sample.Installer">
<Description>
Sample Installer</Description>
<IncludeCode>%occInclude</IncludeCode>
<TimeChanged>64441,73928</TimeChanged>
<TimeCreated>61494,40487</TimeCreated>

<XData name="MyApp">
<Description>
Application Definition</Description>
<XMLNamespace>INSTALLER</XMLNamespace>
<Data><![CDATA[
<Manifest>
<If Condition='$L("${NAMESPACE}")=0'>
<!-- Report an error if the namespace wasn't specified -->
<Error Status="$$$NamespaceDoesNotExist">
<Arg Value="${NAMESPACE}"/>
</Error>
</If>

<Namespace Name="SAMPLES">
<!-- Invoke a helper method on this installer class -->
<Invoke Class="Sample.Installer" Method="Message" CheckStatus="0"/>
</Namespace>

<!-- Do some setup -->
<Var Name="MYAPPDIR" Value="${MYAPPDIR}/myapp"/>
<Var Name="DBRESOURCE" Value="%DB_${NAMESPACE}"/>
<Var Name="MYAPPRESOURCE" Value="%DB_MYAPP"/>
<Var Name="PRODUCTION" Value="MyApp.Production"/>

<!-- Create the namespace, yes it's Ensemble enabled for MyApp -->
<Namespace Name="${NAMESPACE}"
          Create="yes"
          Code="${NAMESPACE}"
          Data="${NAMESPACE}"
          Ensemble="1"
          EnsemblePortalPrefix="myapp"
          EnsemblePortalSuffix="ensemble"
          EnsemblePortalGrant="${DBRESOURCE}"
		  >

<Configuration>

<!-- Create a "data" database -->
<Database Name="${NAMESPACE}"
		 Dir="${MGRDIR}/${NAMESPACE}"
		 Create="yes"
		 Resource="${DBRESOURCE}"
		 PublicPermissions=""/>

<!-- Add the existing MyApp database as the code database for this namespace -->
<Database Name="MYAPP"
		 Dir="${MYAPPDIR}/db"
		 Create="no"
		 Resource="${MYAPPRESOURCE}"
		 PublicPermissions=""/>

<!-- MyApp mappings back to the MYAPP DB.
-->
<GlobalMapping Global="MyAppData.*"    	From="MYAPP"/>
<GlobalMapping Global="cspRule"  		From="MYAPP"/>

<ClassMapping Package="MyApp"    		From="MYAPP"/>

<RoutineMapping Routines="MYAPP" Type="INC" From="MYAPP"/>
</Configuration>

<!-- Check for an upgrade vs install -->
<Invoke Class="Sample.Installer" Method="IsUpgrade" Return="ISUPGRADE"/>

<!-- MyApp setup, load some data in -->
<Import File="${MYAPPDIR}/data/Defaults.gof"/>

<!-- Load patch classes (if they exist) -->
<If Condition='#{##class(%File).DirectoryExists("${MYAPPDIR}/patch/")}'>
<!-- Load a directory full of files, ignore error 5202 ... -->
<Import File="${MYAPPDIR}/patch/" IgnoreErrors="5202" Flags="ck"/>
</If>

<!-- Configure MyApp -->
<Invoke Class="Sample.Installer" Method="SetupDefaults" CheckStatus="1">
<Arg Value="${NAMESPACE}"/>
<Arg Value="${ISUPGRADE}"/>						<!-- True if upgrading -->
</Invoke>

<If Condition="'${ISUPGRADE}">
<!-- Compile the production for a new install -->
<Compile Class="${PRODUCTION}" Flags="ck"/>

<!-- Configure the production -->
<Production Name="${PRODUCTION}">
<Setting Item="FOO"
		Target="Host"
		Setting="Upgraded"
		Value="${ISUPGRADE}"/>
<Setting Item="FOO"
	    Target="Host"
	    Setting="Namespace"
	     Value="${NAMESPACE}"/>
</Production>
</If>

<!-- System settings changes required for MyApp -->
<SystemSetting Name="Config.Miscellaneous.EnableLongStrings" Value="1"/>

<!-- Create a CSP application for the namespace -->
<Var Name="URL" Value='/csp/myapp/#{$ZCVT("${NAMESPACE}","L")}'/>
<Var Name="DIR" Dir='${CSPDIR}myapp/#{$ZCVT("${NAMESPACE}","L")}'/>

<CSPApplication Url="${URL}"
			   Directory="${DIR}"
	           Resource=""
	           Grant="${DBRESOURCE}"
	           Description="MyApp CSP Interface"
	           Recurse="1"
	           CookiePath="/csp/myappp"
	           AuthenticationMethods="32"
	 />

</Namespace>
</Manifest>
]]></Data>
</XData>

<Method name="setup">
<Description>
This is a method generator whose code is generated by XGL.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[&pVars,pLogLevel:%Integer,pInstaller:%Installer.Installer,pLogger:%Installer.AbstractLogger]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Let our XGL document generate code for this method. 
	Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "MyApp")
]]></Implementation>
</Method>

<Method name="Message">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	WRITE $TR($J("",60)," ","="),!
	WRITE $ZV,!
	WRITE $TR($J("",60)," ","="),!
]]></Implementation>
</Method>

<Method name="SetupDefaults">
<Description>
Setup defaults for this MyApp system</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String=$ZU(5),pUpgrading:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	Set tSC=$$$OK,$ZT="Trap"
	Do {
	
	    // Do whatever here ...
		
	} While (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$ERROR($$$CacheError,$ZE)
	Goto Exit
]]></Implementation>
</Method>

<Method name="IsUpgrade">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pNamespace:%String=$ZU(5)</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$RANDOM(2)
]]></Implementation>
</Method>

<Method name="RunInstall">
<Description>
Invoke the installer passing in some variables</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tVars
	#dim tStatus As %Status
	#dim tLogLevel As %Integer = 1
	
	// Initialize any variables we want to pass to the installer
	Set tVars("NAMESPACE") = "TEST"
	
	// Invoke the installer
	Set tStatus = ..setup(.tVars,tLogLevel)
	
	Do:$$$ISERR(tStatus) $system.OBJ.DisplayError(tStatus)
	
	Quit tStatus
]]></Implementation>
</Method>

<Method name="RunInstallWithLog">
<Description>
Invoke the installer passing in some variables</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pLogfile:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tVars
	#dim tStatus As %Status
	#dim tLogLevel As %Integer = 1
	
	// Initialize any variables we want to pass to the installer
	Set tVars("NAMESPACE") = "TEST"

	// Construct a file logger
	#dim tLogger As %Installer.FileLogger = ##class(%Installer.FileLogger).%New(1,pLogfile)
	
	// Invoke the installer
	Set tStatus = ..setup(.tVars,tLogLevel,,tLogger)
	
	Do:$$$ISERR(tStatus) $system.OBJ.DisplayError(tStatus)
	
	Quit tStatus
]]></Implementation>
</Method>
</Class>
</Export>
